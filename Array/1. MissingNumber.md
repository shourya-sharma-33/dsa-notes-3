n is given and we are given n-1 numbers contianing number one to n and we have o find missing number

brute

we loop through from i = 1 to i = n
for each element we loop again
and and if we didnt find it we return tha i

but its n squared

a better approah is hashmap

a hashmap of n of 0s
and whenever we find we say flip to one

finally we reloop and return wheichever is zero

this is o(2n) and space complexity is o(n)
but we can still do better


optimal will be : if only one element is missing
we can substract sum of elemts to the sum of numbers in array
best

and also what can we do it

2 xor 2 = 0
2 xor 2 xor 2 = 0 xor 2 = 2

so we can 
 1 xor 2 xor 3 xor 4 xor 5 xor 1 xor 2 xor 4 xor 5
 

```cpp
int missingNumber (vector<int>&a, int N)
{
    inr xor1 =0, xor2 = 0;
    int n = N - 1;
    for (int i = 0; i<n; i++)
    {
        xor2 = xor2 ^ a[i];
        xor1 = xor1 ^ (i+1);
    }
    xor1 = xor1 ^ N;
    return xor1 ^ xor2;
}
```